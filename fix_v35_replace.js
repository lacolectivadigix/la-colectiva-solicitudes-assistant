const fs = require('fs');
const path = require('path');
const p = path.join(__dirname, 'src', 'app', 'api', 'ai', 'chat', 'route.ts');
let s = fs.readFileSync(p, 'utf8');

const startMarker = "// --- PASO 2: Búsqueda abierta por servicio (v3.2) ---";
const endMarker = "// --- PASO 2: Selección data-driven del servicio ---";
const start = s.indexOf(startMarker);
const end = s.indexOf(endMarker, start);
if (start !== -1 && end !== -1) {
  const header = s.slice(0, start);
  const footer = s.slice(end);
  const newBlock = `// --- PASO 2: Búsqueda abierta por servicio (v3.2) ---\n    if (estado.step === 'PASO_2_ESPERANDO_SERVICIO' && mensajeUsuario.length > 0) {\n      const entrada = normalizeText(mensajeUsuario)\n      const tokens = entrada.split(/\\s+/).filter(Boolean)\n      const { data: servRows, error: servErr } = await supabaseAuthed!\n        .from('servicios')\n        .select('categoria, subcategoria_1, subcategoria_2')\n      if (servErr) return NextResponse.json({ error: 'Error consultando servicios', details: servErr.message }, { status: 400 })\n      const rows = Array.isArray(servRows) ? servRows : []\n      const candidatosServ = rows\n        .map((r: any) => {\n          const servNorm = normalizeText(String(r.subcategoria_2 || ''))\n          const comboNorm = normalizeText(\`${r.categoria || ''} ${r.subcategoria_1 || ''} ${r.subcategoria_2 || ''}\`)\n          const hasIntersection = tokens.some((t) => servNorm.includes(t)) || tokens.some((t) => comboNorm.includes(t))\n          const contains = entrada.length >= 4 && (servNorm.includes(entrada) || comboNorm.includes(entrada))\n          const tokensSubset = tokens.length > 0 && tokens.every((t) => servNorm.includes(t) || comboNorm.includes(t))\n          const score = tokensSubset ? 3 : hasIntersection ? 2 : contains ? 1 : 0\n          return { raw: r, score, len: servNorm.length + comboNorm.length }\n        })\n        .filter((c) => c.score > 0)\n        .sort((a, b) => (b.score - a.score) || (b.len - a.len))\n\n      if (candidatosServ.length === 1) {\n        const elegido = candidatosServ[0].raw\n        const { data: preguntasEspec, error: peErr } = await supabaseAuthed!\n          .from('brief_preguntas')\n          .select('*')\n          .eq('categoria', elegido.categoria)\n          .eq('subcategoria_1', elegido.subcategoria_1)\n          .eq('subcategoria_2', elegido.subcategoria_2)\n          .order('orden', { ascending: true })\n        if (peErr) return NextResponse.json({ error: 'Error consultando preguntas específicas', details: peErr.message }, { status: 400 })\n        const arrE = Array.isArray(preguntasEspec) ? preguntasEspec : []\n        sessionStates.set(user.id, { step: 'PASO_3_ESPECIFICAS_PENDIENTES', clienteId: estado.clienteId || 0, clienteNombre: estado.clienteNombre || '', subdivision: estado.subdivision || null, servicioCategoria: elegido.categoria, subcategoria1: elegido.subcategoria_1, subcategoria2: elegido.subcategoria_2, preguntas: arrE, indice: 0, respuestasGlobales: estado.respuestasGlobales, respuestasEspecificas: {} })\n        const lead = \`Perfecto. Servicio: ${elegido.categoria} / ${elegido.subcategoria_1} / ${elegido.subcategoria_2}.\`\n        const q0 = arrE[0] || {}\n        const textoQ = String((q0 as any).pregunta_texto || (q0 as any).pregunta || (q0 as any).texto || (q0 as any).enunciado || 'Primera pregunta específica')\n        return new NextResponse(\`${lead} ${textoQ}\`, { headers: { 'Content-Type': 'text/plain; charset=utf-8' } })\n      }\n\n      if (candidatosServ.length > 1) {\n        const opciones = candidatosServ.slice(0, Math.min(candidatosServ.length, 6)).map((c) => c.raw)\n        sessionStates.set(user.id, { step: 'PASO_2_ESPERANDO_SERVICIO_AMBIGUO', clienteId: estado.clienteId || 0, clienteNombre: estado.clienteNombre || '', subdivision: estado.subdivision || null, opcionesServicios: opciones, respuestasGlobales: estado.respuestasGlobales })\n        const lista = opciones.map((r: any, i: number) => \`${i + 1}. ${(String(r.categoria || '')).trim().toUpperCase()} / ${(String(r.subcategoria_1 || '')).trim().toUpperCase()} / ${(String(r.subcategoria_2 || '')).trim().toUpperCase()}\`).join('\n')\n        const texto = \`Entendido. Encontré varios servicios posibles para "${mensajeUsuario}":\n${lista}\n¿Con cuál seguimos? Puedes responder con el número o el nombre completo.\`\n        return new NextResponse(texto, { headers: { 'Content-Type': 'text/plain; charset=utf-8' } })\n      }\n\n      // Sin coincidencias: ofrecer guía y fallback suave\n      const { data: filasServ2 } = await supabaseAuthed!\n        .from('servicios')\n        .select('categoria')\n        .order('categoria', { ascending: true })\n      const cats2 = Array.from(new Set((filasServ2 || []).map((r: any) => r.categoria).filter(Boolean)))\n      const texto = \`No encuentro coincidencias claras. Elige una categoría: ${cats2.join(', ')}. Puedes responder con el nombre (flexible) o el número.\`\n      return new NextResponse(texto, { headers: { 'Content-Type': 'text/plain; charset=utf-8' } })\n    }\n`;
  const out = header + newBlock + footer;
  fs.writeFileSync(p, out, 'utf8');
  console.log('Replaced PASO_2_ESPERANDO_SERVICIO block with corrected content.');
} else {
  console.error('Markers for PASO_2 block not found; aborting.');
}
