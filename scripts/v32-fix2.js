const fs=require('fs');
const p='src\\app\\api\\ai\\chat\\route.ts';
let s=fs.readFileSync(p,'utf8');
// 1) Ensure new state exists in union (idempotent)
if(!s.includes("| { step: 'PASO_2_ESPERANDO_SERVICIO'")){
  s=s.replace("| { step: 'PASO_1_ESPERANDO_CLIENTE'", "| { step: 'PASO_1_ESPERANDO_CLIENTE'\n  | { step: 'PASO_2_ESPERANDO_SERVICIO'; clienteId: number; clienteNombre: string; subdivision: string | null; respuestasGlobales: Record<string, string> }");
}
// 2) Update transitions to new state
s=s.replace(/(sessionStates\.set\(user\.id,\s*\{[\s\S]*?step:\s*')PASO_2_ESPERANDO_CATEGORIA'([^\n]*\n)/g, "$1PASO_2_ESPERANDO_SERVICIO'$2");
// 3) Replace transition messages to open service question
s=s.replace(/const texto = `Gracias\. Ahora selecciona la categoría de servicio:[^`]*`;/g, "const texto = `Entendido. Ahora, ¿qué servicio necesitas cotizar?`;");
s=s.replace(/const texto = `¡Claro! Empecemos tu solicitud\. No hay preguntas generales, así que inicia seleccionando la categoría de servicio:[^`]*`;/g, "const texto = `¡Claro! Empecemos tu solicitud. Entendido. Ahora, ¿qué servicio necesitas cotizar?`;");
// 4) Insert new handler before category block if missing
if(!s.includes("estado.step === 'PASO_2_ESPERANDO_SERVICIO'")){
  const marker='// --- PASO 2: Selección data-driven del servicio ---';
  const idx=s.indexOf(marker);
  if(idx!==-1){
    const block=`\n\n    // --- PASO 2 v3.2: Búsqueda abierta de servicio con ILIKE en 3 columnas ---\n    if (estado.step === 'PASO_2_ESPERANDO_SERVICIO' && mensajeUsuario.length > 0) {\n      const termino = mensajeUsuario.trim();\n      const patron = `%${'${'}termino${'}'}%`;\n      const { data: servMatches, error: servErr } = await supabaseAuthed!\n        .from('servicios')\n        .select('id, categoria, subcategoria_1, subcategoria_2')\n        .or(`categoria.ilike.${'${'}patron${'}'},subcategoria_1.ilike.${'${'}patron${'}'},subcategoria_2.ilike.${'${'}patron${'}'}`)\n        .limit(20);\n      if (servErr) return NextResponse.json({ error: 'Error buscando servicios', details: servErr.message }, { status: 400 });\n      const rows = Array.isArray(servMatches) ? servMatches : [];\n\n      if (rows.length === 0) {\n        const texto = `No he podido encontrar el servicio '${'${'}termino${'}'}' en nuestra base de datos. ¿Puedes intentarlo de nuevo?`;\n        return new NextResponse(texto, { headers: { 'Content-Type': 'text/plain; charset=utf-8' } });\n      }\n\n      const nInput = normalizeText(termino);\n      const exactos = rows.filter(r => {\n        const nc = normalizeText(String(r.categoria || ''));\n        const n1 = normalizeText(String(r.subcategoria_1 || ''));\n        const n2 = normalizeText(String(r.subcategoria_2 || ''));\n        return nc === nInput || n1 === nInput || n2 === nInput;\n      });\n\n      const elegido = (exactos.length === 1 ? exactos[0] : (rows.length === 1 ? rows[0] : null));\n      if (elegido) {\n        const { data: preguntasEspec, error: peErr } = await supabaseAuthed!\n          .from('brief_preguntas')\n          .select('*')\n          .eq('categoria', elegido.categoria)\n          .eq('subcategoria_1', elegido.subcategoria_1)\n          .eq('subcategoria_2', elegido.subcategoria_2)\n          .order('orden', { ascending: true });\n        if (peErr) return NextResponse.json({ error: 'Error consultando preguntas específicas', details: peErr.message }, { status: 400 });\n        const arrE = Array.isArray(preguntasEspec) ? preguntasEspec : [];\n        sessionStates.set(user.id, {\n          step: 'PASO_3_ESPECIFICAS_PENDIENTES',\n          clienteId: estado.clienteId,\n          clienteNombre: estado.clienteNombre,\n          subdivision: estado.subdivision,\n          servicioCategoria: elegido.categoria,\n          subcategoria1: elegido.subcategoria_1,\n          subcategoria2: elegido.subcategoria_2,\n          preguntas: arrE,\n          indice: 0,\n          respuestasGlobales: estado.respuestasGlobales,\n          respuestasEspecificas: {}\n        });\n        const lead = `¡Perfecto! Para tu solicitud de '${'${'}String(elegido.subcategoria_2 || elegido.subcategoria_1 || elegido.categoria)${'}'}', necesito hacerte unas preguntas...`;\n        const q0 = arrE[0] || {};\n        const textoQ = String((q0 as any).pregunta_texto || (q0 as any).pregunta || (q0 as any).texto || (q0 as any).enunciado || 'Primera pregunta específica');\n        return new NextResponse(`${'${'}lead${'}'} ${'${'}textoQ${'}'}`, { headers: { 'Content-Type': 'text/plain; charset=utf-8' } });\n      }\n\n      const opciones = rows.slice(0, Math.min(rows.length, 10));\n      sessionStates.set(user.id, {\n        step: 'PASO_2_ESPERANDO_SERVICIO_AMBIGUO',\n        clienteId: estado.clienteId,\n        clienteNombre: estado.clienteNombre,\n        subdivision: estado.subdivision,\n        opcionesServicios: opciones.map(r => ({ categoria: r.categoria, subcategoria_1: r.subcategoria_1, subcategoria_2: r.subcategoria_2 })),\n        respuestasGlobales: estado.respuestasGlobales\n      });\n      const lista = opciones.map((r: any, i: number) => `${'${'}i + 1${'}'}. ${(String(r.categoria || '')).trim().toUpperCase()} / ${(String(r.subcategoria_1 || '')).trim().toUpperCase()} / ${(String(r.subcategoria_2 || '')).trim().toUpperCase()}`).join('\n');\n      const texto = `Entendido. Al buscar '${'${'}termino${'}'}', encontré ${'${'}opciones.length${'}'} opciones:\n${'${'}lista${'}'}\n¿A cuál te refieres?`;\n      return new NextResponse(texto, { headers: { 'Content-Type': 'text/plain; charset=utf-8' } });\n    }\n`;
    s = s.slice(0, idx) + block + s.slice(idx);
  }
}
fs.writeFileSync(p,s);
